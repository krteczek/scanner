<?php
declare(strict_types=1);

namespace Scanner\Services;

class ProjectScanner
{
    private array $config;
    
public function __construct(array $config)
{
    $this->config = $config;
    
    // DEBUG - co dostÃ¡vÃ¡me?
    error_log("=== ProjectScanner constructor ===");
    error_log("Config keys: " . implode(', ', array_keys($config)));
    error_log("Has ignore_patterns: " . (isset($config['ignore_patterns']) ? 'YES' : 'NO'));
    if (isset($config['ignore_patterns'])) {
        error_log("Count: " . count($config['ignore_patterns']));
        error_log("All: " . implode(', ', $config['ignore_patterns']));
    }
    
    // Pokud ignore_patterns neexistujÃ­, vytvoÅ™ defaultnÃ­
    if (!isset($config['ignore_patterns'])) {
        error_log("WARNING: No ignore_patterns found, using defaults");
        $this->config['ignore_patterns'] = [
            'vendor/',
            'node_modules/',
            '.git/',
            'logs/',
            'tmp/'
        ];
    }
}

    /**
     * Scanuje projekt a vracÃ­ strukturu s metadaty
     * @return array [files, directories, stats]
     */
    public function scan(string $projectPath): array
    {
        $result = [
            'files' => [],
            'directories' => [],
            'stats' => ['total_files' => 0, 'total_size' => 0]
        ];
        
        $this->scanDirectory($projectPath, $result, '');
        
        return $result;
    }
    
    private function scanDirectory(string $path, array &$result, string $relativePath): void
    {
    	
        if (!is_dir($path) || !is_readable($path)) {
            return;
        }
        
        $items = scandir($path);
        foreach ($items as $item) {
            if ($item === '.' || $item === '..') {
                continue;
            }
            
            $fullPath = $path . '/' . $item;
            $itemRelativePath = ($relativePath ? $relativePath . '/' : '') . $item;
            
            if (is_dir($fullPath)) {
                // PÅ™eskoÄ ignorovanÃ© sloÅ¾ky
if ($this->shouldIgnore($itemRelativePath)) {
    error_log("ProjectScanner: FIRST IGNORE CALL for '$itemRelativePath'");
    continue;
}                
                $result['directories'][] = [
                    'path' => $itemRelativePath,
                    'name' => $item
                ];
                
                $this->scanDirectory($fullPath, $result, $itemRelativePath);
                
            } elseif (is_file($fullPath)) {
                // PÅ™eskoÄ ignorovanÃ© soubory
// Na Å™Ã¡dku 62 (druhÃ© volÃ¡nÃ­):
if ($this->shouldIgnore($itemRelativePath)) {
    error_log("ProjectScanner: SECOND IGNORE CALL for '$itemRelativePath'");
    continue;
}                
                $result['files'][] = [
                    'path' => $itemRelativePath,
                    'name' => $item,
                    'size' => filesize($fullPath),
                    'extension' => pathinfo($item, PATHINFO_EXTENSION),
                    'modified' => filemtime($fullPath)
                ];
                
                $result['stats']['total_files']++;
                $result['stats']['total_size'] += filesize($fullPath);
            }
        }
    }
private function shouldIgnore(string $path): bool
{    
    $ignorePatterns = $this->config['ignore_patterns'] ?? [];
    
    foreach ($ignorePatterns as $pattern) {
        // PÅ™esnÃ¡ shoda
        if ($path === $pattern) {
            error_log("    âœ… EXACT MATCH: $path == $pattern");
            return true;
        }
        
        // AdresÃ¡Å™ (konÄÃ­ /)
        if (substr($pattern, -1) === '/') {
            // Kontrola: "vendor/" matchne "vendor/" i "vendor/composer"
            if (strpos($path . '/', $pattern) === 0) {
                error_log("    âœ… DIRECTORY MATCH: $path starts with $pattern");
                return true;
            }
        }
        
        // Soubor konÄÃ­cÃ­ na ~ (speciÃ¡lnÃ­ pÅ™Ã­pad)
        if ($pattern === '~' && substr($path, -1) === '~') {
            error_log("    âœ… BACKUP FILE MATCH: $path ends with ~");
            return true;
        }
        
        // PÅ™esnÃ½ nÃ¡zev souboru
        if (basename($path) === $pattern) {
            error_log("    âœ… FILENAME MATCH: basename($path) == $pattern");
            return true;
        }
        
        // GLOB PATTERNY jako *.log, *.~, atd. - TOTO CHYBÃ!
        if (strpos($pattern, '*') !== false) {
            // PÅ™evod glob patternu na regex
            $regex = $this->globToRegex($pattern);
            if (preg_match($regex, basename($path))) {
                error_log("    âœ… GLOB MATCH: $path matches $pattern");
                return true;
            }
        }
        
        error_log("    âŒ NO MATCH for pattern '$pattern'");
    }
    
    error_log("=== NO IGNORE PATTERN MATCHED ===");
    return false;
}

/**
 * PÅ™evÃ¡dÃ­ glob pattern na regex
 * napÅ™.: *.log -> /^.*\.log$/, app.* -> /^app\..*$/
 */
private function globToRegex(string $pattern): string
{
    $pattern = str_replace('.', '\.', $pattern);
    $pattern = str_replace('*', '.*', $pattern);
    $pattern = str_replace('?', '.', $pattern);
    
    return '/^' . $pattern . '$/i';
}


    public function scanProject(string $path, string $prefix = ''): array
    {
        $structureWithMetadata = $this->scanProjectWithMetadata($path, $prefix);
        return array_column($structureWithMetadata, 'display');
    }
    
        /**
     * RekurzivnÄ› proskenuje projektovÃ½ adresÃ¡Å™ a vrÃ¡tÃ­ strukturu s metadaty
     * ProchÃ¡zÃ­ vÅ¡echny soubory a adresÃ¡Å™e, aplikuje ignore pravidla
     * VracÃ­ kompletnÃ­ strukturu s metadaty pro kaÅ¾dou poloÅ¾ku
     *
     * @param string $path Cesta k adresÃ¡Å™i pro skenovÃ¡nÃ­
     * @param string $prefix Prefix pro stromovÃ© zobrazenÃ­ (pro rekurzi)
     * @return array StromovÃ¡ struktura projektu s metadaty
     * @throws RuntimeException Pokud nelze naÄÃ­st adresÃ¡Å™
     */
    public function scanProjectWithMetadata(string $path, string $prefix = ''): array
    {
        $output = [];
        $items = @scandir($path);

        if ($items === false) {
            throw new RuntimeException("Nelze naÄÃ­st adresÃ¡Å™: $path");
        }

        foreach ($items as $item) {
            if ($item === '.' || $item === '..') continue;
            $fullPath = $path . '/' . $item;

            if ($this->shouldIgnore($fullPath)) continue;

            $metadata = $this->getFileMetadata($fullPath);
            
            if (is_dir($fullPath)) {
                $output[] = [
                    'type' => 'directory',
                    'display' => $prefix . 'ğŸ“ ' . $item . '/',
                    'metadata' => $metadata
                ];
                $output = array_merge($output, $this->scanProjectWithMetadata($fullPath, $prefix . 'â”‚   '));
            } else {
                $sizeInfo = $metadata['size_bytes'] > 0 ? ' (' . $metadata['size'] . ')' : '';
                $output[] = [
                    'type' => 'file', 
                    'display' => $prefix . 'ğŸ“„ ' . $item . $sizeInfo,
                    'metadata' => $metadata
                ];
            }
        }
        return $output;
    }

    /**
     * ZÃ­skÃ¡ metadata o souboru nebo adresÃ¡Å™i
     * ShromaÅ¾Äuje informace o velikosti, Äasu modifikace, poÄtu Å™Ã¡dkÅ¯ a typech
     * Pro PHP soubory navÃ­c poÄÃ­tÃ¡ Å™Ã¡dky kÃ³du
     *
     * @param string $filePath Cesta k souboru nebo adresÃ¡Å™i
     * @return array Metadata souboru obsahujÃ­cÃ­ name, path, size, lines, modified, type, extension, has_php
     */
    public function getFileMetadata(string $filePath): array
    {
        if (!file_exists($filePath)) {
            return [];
        }

        $stats = stat($filePath);
        $lines = 0;
        
        if (is_file($filePath) && pathinfo($filePath, PATHINFO_EXTENSION) === 'php') {
            $lines = count(file($filePath));
        }
        
        return [
            'name' => basename($filePath),
            'path' => $filePath,
            'size' => $this->formatFileSize($stats['size']),
            'size_bytes' => $stats['size'],
            'lines' => $lines,
            'modified' => date('Y-m-d H:i:s', $stats['mtime']),
            'type' => is_dir($filePath) ? 'directory' : 'file',
            'extension' => pathinfo($filePath, PATHINFO_EXTENSION),
            'has_php' => (pathinfo($filePath, PATHINFO_EXTENSION) === 'php')
        ];
    }

    /**
     * FormÃ¡tuje velikost souboru do ÄitelnÃ©ho formÃ¡tu s jednotkami
     * Automaticky vybÃ­rÃ¡ vhodnou jednotku (B, KB, MB) podle velikosti
     *
     * @param int $bytes Velikost souboru v bytech
     * @return string NaformÃ¡tovanÃ¡ velikost souboru s jednotkou
     */
    private function formatFileSize(int $bytes): string
    {
        if ($bytes >= 1048576) {
            return round($bytes / 1048576, 1) . 'MB';
        } elseif ($bytes >= 1024) {
            return round($bytes / 1024, 1) . 'KB';
        } else {
            return $bytes . 'B';
        }
    }






}