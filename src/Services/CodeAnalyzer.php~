<?php
// scanner/src/Services/CodeAnalyzer.php

/**
 * AnalyzÃ¡tor kÃ³du pro kontrolu kvality s detailnÃ­m reportingem
 * 
 * @package Scanner\Services
 * @author KRS3
 * @version 2.1
 */

declare(strict_types=1);

namespace Scanner\Services;

use RuntimeException;

class CodeAnalyzer
{
    private array $config;
    
    // ğŸ” NOVÃ‰: Definice problÃ©mÅ¯ a jejich popisÅ¯
    private const PROBLEM_DEFINITIONS = [
        'missing_phpdoc_class' => [
            'description' => 'TÅ™Ã­da nemÃ¡ PHP Doc komentÃ¡Å™',
            'severity' => 'warning',
            'suggestion' => 'PÅ™idej /** ... */ dokumentaÄnÃ­ komentÃ¡Å™ pÅ™ed definici tÅ™Ã­dy',
            'example' => '/**\n * Popis tÅ™Ã­dy\n * @author ...\n */\nclass ClassName'
        ],
        'missing_phpdoc_method' => [
            'description' => 'Metoda nemÃ¡ PHP Doc komentÃ¡Å™', 
            'severity' => 'warning',
            'suggestion' => 'Dokumentuj metodu pomocÃ­ /** ... */ pÅ™ed definicÃ­ metody',
            'example' => '/**\n * Popis metody\n * @param string $param Popis parametru\n * @return bool NÃ¡vratovÃ¡ hodnota\n */'
        ],
        'missing_logger' => [
            'description' => 'Soubor nemÃ¡ logger pÅ™estoÅ¾e by mÄ›l',
            'severity' => 'warning', 
            'suggestion' => 'PÅ™idej use ...\\Logger; a pouÅ¾Ã­vej $this->logger->info() pro dÅ¯leÅ¾itÃ© operace',
            'example' => 'use App\\Logger\\Logger;\n\nclass Service {\n    private Logger $logger;\n    \n    public function action() {\n        $this->logger->info(\'Action executed\');\n    }\n}'
        ],
        'no_namespace' => [
            'description' => 'Soubor nemÃ¡ namespace pÅ™estoÅ¾e by mÄ›l',
            'severity' => 'error',
            'suggestion' => 'PÅ™idej namespace podle struktury adresÃ¡Å™e (PSR-4)',
            'example' => 'namespace App\\Controllers;\n\nclass UserController'
        ],
        'no_strict_types' => [
            'description' => 'ChybÃ­ declare(strict_types=1)',
            'severity' => 'error',
            'suggestion' => 'PÅ™idej declare(strict_types=1); na zaÄÃ¡tek souboru za <?php',
            'example' => '<?php\ndeclare(strict_types=1);'
        ],
        'syntax_error' => [
            'description' => 'Syntax error v PHP kÃ³du',
            'severity' => 'critical',
            'suggestion' => 'Oprav syntaxi podle chybovÃ© hlÃ¡Å¡ky PHP',
            'example' => ''
        ]
    ];
    
    /**
     * Constructor
     *
     * @param array $config Konfigurace aplikace
     */
    public function __construct(array $config)
    {
        $this->config = $config;
    }

    /**
     * Analyzuje PHP soubory s detailnÃ­m reportingem problÃ©mÅ¯
     *
     * @param string $projectPath Cesta k projektu
     * @param array $aiRules Pravidla pro analÃ½zu
     * @return array VÃ½sledky analÃ½zy s detailnÃ­mi problÃ©my
     */
    public function analyzeCodeQuality(string $projectPath, array $aiRules): array
    {
        $analysis = [
            'soubory_s_problemy' => [], // ğŸ” NOVÃ‰: DetailnÃ­ problÃ©my
            'soubory_bez_phpdoc' => [],
            'soubory_bez_loggeru' => [], 
            'soubory_bez_namespaces' => [],
            'celkem_souboru' => 0,
            'celkem_radku' => 0,
            'problemy_podle_zavaznosti' => [ // ğŸ” NOVÃ‰: Kategorizace
                'critical' => [],
                'error' => [],
                'warning' => [],
                'info' => []
            ]
        ];

        $phpFiles = $this->findPhpFiles($projectPath);

        foreach ($phpFiles as $phpFile) {
            $analysis['celkem_souboru']++;
            $fileAnalysis = $this->analyzePhpFile($phpFile, $aiRules);
            $analysis['celkem_radku'] += $fileAnalysis['radku'];

            // ğŸ” NOVÃ‰: UklÃ¡dÃ¡nÃ­ detailnÃ­ch problÃ©mÅ¯
            if (!empty($fileAnalysis['problemy'])) {
                $analysis['soubory_s_problemy'][$phpFile] = $fileAnalysis['problemy'];
                
                // Kategorizace podle zÃ¡vaÅ¾nosti
                foreach ($fileAnalysis['problemy'] as $problem) {
                    $analysis['problemy_podle_zavaznosti'][$problem['severity']][] = $problem;
                }
            }

            // Zachovat pÅ¯vodnÃ­ strukturu pro kompatibilitu
            if (!$fileAnalysis['ma_phpdoc']) {
                $analysis['soubory_bez_phpdoc'][] = $phpFile;
            }

            if (!$fileAnalysis['ma_logger'] && $this->shouldHaveLogger($phpFile)) {
                $analysis['soubory_bez_loggeru'][] = $phpFile;
            }

            if (!$fileAnalysis['ma_namespace'] && $this->shouldHaveNamespace($phpFile)) {
                $analysis['soubory_bez_namespaces'][] = $phpFile;
            }
        }

        return $analysis;
    }

    /**
     * Analyzuje jednotlivÃ½ PHP soubor s detailnÃ­mi problÃ©my
     *
     * @param string $filePath Cesta k PHP souboru
     * @param array $aiRules Pravidla pro analÃ½zu
     * @return array VÃ½sledky analÃ½zy souboru s problÃ©my
     */
    private function analyzePhpFile(string $filePath, array $aiRules): array
    {
        $content = file_get_contents($filePath);
        $analysis = [
            'ma_phpdoc' => false,
            'ma_logger' => false, 
            'ma_strict_types' => false,
            'ma_namespace' => false,
            'radku' => count(file($filePath)),
            'problemy' => [], // ğŸ” NOVÃ‰: Pole problÃ©mÅ¯
            'chyby' => []
        ];

        // ğŸ” DETAILLNÃ KONTROLY S PROBLEM REPORTINGEM
        
        // Kontrola PHP Doc s detaily
        $phpdocCheck = $this->checkPhpDocWithDetails($content, $filePath);
        $analysis['ma_phpdoc'] = $phpdocCheck['has_phpdoc'];
        $analysis['problemy'] = array_merge($analysis['problemy'], $phpdocCheck['problems']);

        // Kontrola strict_types
        if (!str_contains($content, "declare(strict_types=1)")) {
            $analysis['problemy'][] = $this->createProblem(
                'no_strict_types', 
                $filePath,
                'ChybÃ­ strict types declaration'
            );
        } else {
            $analysis['ma_strict_types'] = true;
        }

        // Kontrola namespaces
        $namespaceCheck = $this->checkNamespacesWithDetails($content, $filePath);
        $analysis['ma_namespace'] = $namespaceCheck['has_namespace'];
        $analysis['problemy'] = array_merge($analysis['problemy'], $namespaceCheck['problems']);

        // Kontrola loggeru
        $loggerCheck = $this->checkLoggerWithDetails($content, $filePath);
        $analysis['ma_logger'] = $loggerCheck['has_logger'];
        $analysis['problemy'] = array_merge($analysis['problemy'], $loggerCheck['problems']);

        // Kontrola syntaxe
        if ($this->config['system']['check_syntax'] ?? true) {
            $syntaxProblems = $this->checkSyntaxWithDetails($filePath);
            $analysis['problemy'] = array_merge($analysis['problemy'], $syntaxProblems);
        }

        return $analysis;
    }

    /**
     * Kontroluje PHP Doc s detailnÃ­m problÃ©m reportingem
     *
     * @param string $content Obsah souboru
     * @param string $filePath Cesta k souboru
     * @return array VÃ½sledky kontroly PHP Doc
     */
    private function checkPhpDocWithDetails(string $content, string $filePath): array
    {
        $result = ['has_phpdoc' => false, 'problems' => []];
        
        // Kontrola existence PHP Doc pro tÅ™Ã­du
        if (preg_match('/class\s+(\w+)/', $content, $classMatches)) {
            $className = $classMatches[1];
            $classDocPattern = '/\/\*\*[\s\S]*?\*\/\s*class\s+' . $className . '/';
            
            if (!preg_match($classDocPattern, $content)) {
                $result['problems'][] = $this->createProblem(
                    'missing_phpdoc_class',
                    $filePath,
                    "TÅ™Ã­da {$className} nemÃ¡ PHP Doc komentÃ¡Å™"
                );
            } else {
                $result['has_phpdoc'] = true;
            }
        }
        
        // Kontrola PHP Doc pro metody (zÃ¡kladnÃ­)
        if (preg_match_all('/function\s+(\w+)\s*\(/m', $content, $methodMatches)) {
            foreach ($methodMatches[1] as $methodName) {
                if ($methodName === '__construct' || $methodName === '__destruct') {
                    continue; // Konstruktor a destruktor mohou bÃ½t bez PHP Doc
                }
                
                $methodDocPattern = '/\/\*\*[\s\S]*?\*\/\s*function\s+' . $methodName . '\s*\(/';
                if (!preg_match($methodDocPattern, $content)) {
                    $result['problems'][] = $this->createProblem(
                        'missing_phpdoc_method',
                        $filePath, 
                        "Metoda {$methodName} nemÃ¡ PHP Doc komentÃ¡Å™"
                    );
                }
            }
        }
        
        return $result;
    }

    /**
     * Kontroluje namespaces s detailnÃ­m problÃ©m reportingem
     *
     * @param string $content Obsah souboru
     * @param string $filePath Cesta k souboru
     * @return array VÃ½sledky kontroly namespaces
     */
    private function checkNamespacesWithDetails(string $content, string $filePath): array
    {
        $result = ['has_namespace' => false, 'problems' => []];
        
        $hasNamespace = preg_match('/^namespace\s+[a-zA-Z0-9_\\\\]+;/m', $content) === 1;
        $result['has_namespace'] = $hasNamespace;
        
        if (!$hasNamespace && $this->shouldHaveNamespace($filePath)) {
            $result['problems'][] = $this->createProblem(
                'no_namespace',
                $filePath,
                'Soubor by mÄ›l mÃ­t namespace podle PSR-4'
            );
        }
        
        return $result;
    }

    /**
     * Kontroluje logger s detailnÃ­m problÃ©m reportingem
     *
     * @param string $content Obsah souboru
     * @param string $filePath Cesta k souboru
     * @return array VÃ½sledky kontroly loggeru
     */
    private function checkLoggerWithDetails(string $content, string $filePath): array
    {
        $result = ['has_logger' => false, 'problems' => []];
        
        $hasLogger = strpos($content, "Logger::") !== false ||
                   preg_match('/use.*Logger/', $content) ||
                   strpos($content, "\\Logger") !== false;
        
        $result['has_logger'] = $hasLogger;
        
        if (!$hasLogger && $this->shouldHaveLogger($filePath)) {
            $result['problems'][] = $this->createProblem(
                'missing_logger',
                $filePath, 
                'Soubor by mÄ›l mÃ­t logger pro dÅ¯leÅ¾itÃ© operace'
            );
        }
        
        return $result;
    }

    /**
     * Kontroluje syntaxi s detailnÃ­m problÃ©m reportingem
     *
     * @param string $filePath Cesta k souboru
     * @return array Pole syntax problÃ©mÅ¯
     */
    private function checkSyntaxWithDetails(string $filePath): array
    {
        $problems = [];
        
        try {
            $phpBinary = $this->getPhpBinary();
            $output = [];
            $returnCode = 0;

            $command = '"' . $phpBinary . '" -l ' . escapeshellarg($filePath) . ' 2>&1';
            exec($command, $output, $returnCode);

            if ($returnCode !== 0) {
                $problems[] = $this->createProblem(
                    'syntax_error',
                    $filePath,
                    'Syntax error: ' . implode(" ", $output)
                );
            }
        } catch (RuntimeException $e) {
            $problems[] = $this->createProblem(
                'syntax_error',
                $filePath,
                'Chyba PHP binÃ¡rky: ' . $e->getMessage()
            );
        }
        
        return $problems;
    }

    /**
     * VytvoÅ™Ã­ strukturovanÃ½ problÃ©m
     *
     * @param string $type Typ problÃ©mu
     * @param string $filePath Cesta k souboru
     * @param string $customMessage VlastnÃ­ zprÃ¡va
     * @return array StrukturovanÃ½ problÃ©m
     */
    private function createProblem(string $type, string $filePath, string $customMessage = ''): array
    {
        $definition = self::PROBLEM_DEFINITIONS[$type] ?? [
            'description' => 'NeznÃ¡mÃ½ problÃ©m',
            'severity' => 'warning',
            'suggestion' => 'Zkontroluj soubor',
            'example' => ''
        ];
        
        return [
            'type' => $type,
            'file' => $filePath,
            'filename' => basename($filePath),
            'description' => $customMessage ?: $definition['description'],
            'severity' => $definition['severity'],
            'suggestion' => $definition['suggestion'],
            'example' => $definition['example'] ?? ''
        ];
    }

 <?php
// scanner/src/Services/CodeAnalyzer.php

// ... (vÅ¡echno nahoÅ™e zÅ¯stÃ¡vÃ¡ stejnÃ©)

    /**
     * InteligentnÄ› detekuje PHP binÃ¡rku pro aktuÃ¡lnÃ­ systÃ©m
     *
     * @return string Cesta k PHP binÃ¡rce
     * @throws RuntimeException Pokud nelze najÃ­t PHP
     */
    public function getPhpBinary(): string
    {
        $os = strtoupper(substr(PHP_OS, 0, 3));
        
        // Nejprve zkusÃ­me systÃ©movÃ© PHP
        if ($os !== 'WIN') {
            $systemPhp = shell_exec('which php 2>/dev/null');
            if ($systemPhp && $this->isValidPhpBinary(trim($systemPhp))) {
                return trim($systemPhp);
            }
        }
        
        // Pak fallback na konfiguraci
        $config = $this->config['system'] ?? [];
        
        if ($os === 'WIN') {
            $windowsPath = $config['windows_php_path'] ?? 'C:\\xampp\\php\\php.exe';
            if ($this->isValidPhpBinary($windowsPath)) {
                return $windowsPath;
            }
        } else {
            $linuxPath = $config['linux_php_path'] ?? '/opt/lampp/bin/php';
            if ($this->isValidPhpBinary($linuxPath)) {
                return $linuxPath;
            }
        }
        
        // Nakonec zkusÃ­me vÅ¡echny moÅ¾nÃ© cesty
        return $this->detectPhpBinary();
    }

    /**
     * Detekuje PHP binÃ¡rku prochÃ¡zenÃ­m vÅ¡ech moÅ¾nÃ½ch cest
     *
     * @return string Cesta k PHP binÃ¡rce
     * @throws RuntimeException Pokud nelze najÃ­t PHP
     */
    private function detectPhpBinary(): string
    {
        $possible_paths = [
            // Linux/Mac
            '/opt/lampp/bin/php',
            '/usr/bin/php',
            '/usr/local/bin/php',
            'php',
            // Windows
            'C:\\xampp\\php\\php.exe',
            'C:\\Program Files\\xampp\\php\\php.exe',
            'php.exe'
        ];
        
        foreach ($possible_paths as $path) {
            if ($this->isValidPhpBinary($path)) {
                return $path;
            }
        }
        
        throw new RuntimeException('Nelze najÃ­t PHP binÃ¡rku! Zkontrolujte konfiguraci nebo nainstalujte PHP.');
    }

    /**
     * OvÄ›Å™Ã­ zda je PHP binÃ¡rka platnÃ¡ a spustitelnÃ¡
     *
     * @param string $path Cesta k PHP binÃ¡rce
     * @return bool True pokud je binÃ¡rka platnÃ¡
     */
    private function isValidPhpBinary(string $path): bool
    {
        // Pro systÃ©movÃ© cesty (php, php.exe)
        if (strpos($path, '/') === false && strpos($path, '\\') === false) {
            $output = [];
            $returnCode = 0;
            exec("$path -v 2>/dev/null", $output, $returnCode);
            return $returnCode === 0;
        }
        
        // Pro plnÃ© cesty
        return file_exists($path) && is_executable($path);
    }

    /**
     * Najde vÅ¡echny PHP soubory v projektu
     *
     * @param string $path Cesta k projektu
     * @return array Seznam PHP souborÅ¯
     */
    private function findPhpFiles(string $path): array
    {
        $phpFiles = [];

        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($path, \RecursiveDirectoryIterator::SKIP_DOTS)
        );

        foreach ($iterator as $file) {
            if ($file->isFile() && $file->getExtension() === 'php') {
                $phpFiles[] = $file->getPathname();
            }
        }

        return $phpFiles;
    }

    /**
     * UrÄÃ­ zda by soubor mÄ›l mÃ­t namespace
     *
     * @param string $filePath Cesta k souboru
     * @return bool True pokud by mÄ›l mÃ­t namespace
     */
    private function shouldHaveNamespace(string $filePath): bool
    {
        $shouldHavePatterns = [
            '/src\//',
            '/app\//',
            '/Controller\.php$/',
            '/Service\.php$/',
            '/Model\.php$/'
        ];

        $canBeWithoutPatterns = [
            '/index\.php$/',
            '/autoloader\.php$/',
            '/autoload\.php$/',
            '/config\//',
            '/public\//'
        ];

        foreach ($canBeWithoutPatterns as $pattern) {
            if (preg_match($pattern, $filePath)) {
                return false;
            }
        }

        foreach ($shouldHavePatterns as $pattern) {
            if (preg_match($pattern, $filePath)) {
                return true;
            }
        }

        return false;
    }

    /**
     * UrÄÃ­ zda by soubor mÄ›l mÃ­t logger
     *
     * @param string $filePath Cesta k souboru
     * @return bool True pokud by mÄ›l mÃ­t logger
     */
    private function shouldHaveLogger(string $filePath): bool
    {
        $patterns = [
            '/app\/Services\//',
            '/app\/Controllers\//',
            '/app\/Auth\//',
            '/Controller\.php$/',
            '/Service\.php$/'
        ];

        foreach ($patterns as $pattern) {
            if (preg_match($pattern, $filePath)) {
                return true;
            }
        }

        return false;
    }
}
?>}
?>